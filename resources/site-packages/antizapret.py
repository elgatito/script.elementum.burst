# -*- coding: utf-8 -*-

#
# Module taken from https://github.com/afedchin/antizapret
# Many thanks to @afedchin !
# Modificated by @elgatito .
#

import os
import re
import fnmatch
import math
import threading
import socket
import struct
import string
import urllib2
import xbmc
import xbmcaddon
from contextlib import contextmanager, closing

__addon__ = xbmcaddon.Addon()
CACHE_DIR = xbmc.translatePath(__addon__.getAddonInfo("profile"))
PAC_URL = "http://antizapret.prostovpn.org/proxy.pac"
USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36"
CACHE = 24 * 3600  # 24 hour caching
LOCKS = {}
_config = {}
_custom_hosts = []
digs = string.digits + string.ascii_letters

# Use these values for debugging
# CACHE_DIR="/var/tmp/pac/"
# CACHE = 1

try:
    if not os.path.exists(CACHE_DIR):
        os.makedirs(CACHE_DIR)
except:
    pass

@contextmanager
def shelf(filename, ttl=0):
    import shelve
    filename = os.path.join(CACHE_DIR, filename)
    with LOCKS.get(filename, threading.RLock()):
        with closing(shelve.open(filename, writeback=True)) as d:
            import time
            if not d:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            elif ttl > 0 and (time.time() - d["created_at"]) > ttl:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            yield d["data"]


def config():
    global _config
    if not _config:
        with shelf("antizapret.pac_config", ttl=CACHE) as pac:
            if not pac.get("value"):
                xbmc.log("[script.elementum.burst]: Fetching Antizapret PAC file", level=xbmc.LOGNOTICE)
                try:
                    # with open("/home/elgato/Downloads/proxy.pac") as file:
                    #     # data = file.read()
                    #     data = file.read().replace('\n', '').replace('\r', '')
                    #     print "read len: %d" % (len(data))
                    data = urllib2.urlopen(PAC_URL).read()
                except:
                    data = ""

                pac["value"] = {
                    "servers_usual": [],
                    "servers_special": [],
                    "domains": [],
                    "specials": [],
                    "ips": [],
                    "dn": [],
                }

                # Find servers for specific cases
                r_usual = re.search(r'if \(yip === 1 \|\| shost === curarr\[i\]\) \{.*?return "(.*?)".*?\}', data, flags=re.DOTALL)
                r_special = re.search(r'if \(isInNet\(oip, special\[i\]\[0\], special\[i\]\[1\]\)\) \{return "(.*?)";\}', data, flags=re.DOTALL)
                
                # Find arrays containing domains
                res = re.findall(r'(d_\w+) = "(.*?)"', data, flags=re.DOTALL)

                r_list_special = re.search(r'special = \[(.*?)\];', data, flags=re.DOTALL)
                r_dn = re.search(r'dn = \{(.*?)\};', data, flags=re.DOTALL)

                if r_usual:
                    pac["value"]["servers_usual"] = get_servers(r_usual.group(1))
                if r_special:
                    pac["value"]["servers_special"] = get_servers(r_special.group(1))

                if r_dn:
                    ary = r_dn.group(1).replace("'", "").split(", ")
                    for i in ary:
                        # ary2 = i.split(":")
                        # pac["value"]["dn"].append([i[1], i[0]])
                        pac["value"]["dn"].append(i.split(":"))

                if r_list_special:
                    for i in r_list_special.group(1).replace('],[', ']  ,  [').replace('"', '').split("  ,  "):
                        s = i.replace('[', '').replace(']', '').rstrip(',')
                        ary = s.split(', ')
                        pac["value"]["specials"].append([ary[0], int(ary[1])])

                if res:
                    domains = ""
                    ips = ""

                    for r in res:
                        l = r[1].replace('\\', '')

                        if r[0] == 'd_ipaddr':
                            ips += l
                        else:
                            domains += l

                    pac["value"]["domains"] = domains.split(" ")
                    pac["value"]["ips"] = re.findall(r'.{8}', ips, flags=re.DOTALL)

            _config = pac["value"]
    return _config

def nmfc(b):
    return socket.inet_ntoa(struct.pack("<L", b))

def pphs(n):
    r = int2base(n, 16)
    if len(r) % 2:
        return "0" + r 
    return r

def get_servers(inp):
    ary = {}
    for e in inp.split("; "):
        r = e.replace(";", "").split(" ")
        r[0] = r[0].lower()
        if r[0] == 'proxy':
            r[0] = 'http'
        elif r[0] == 'direct':
            continue
        
        # ary[r[0]] = r[0] + "://" + r[1]
        ary[r[0]] = r[1]
    return ary


def config_add(host):
    host = host.split(':')[0]
    if host not in _custom_hosts:
        _custom_hosts.append(host)


class AntizapretProxyHandler(urllib2.ProxyHandler, object):

    def __init__(self):
        self.config = config()
        urllib2.ProxyHandler.__init__(self, {
            "http": "<empty>",
            "https": "<empty>",
            "ftp": "<empty>",
        })

    def proxy_open(self, req, proxy, rtype):
        import socket
        global _custom_hosts

        host = req.get_host().split(":")[0]

        if re.search(r'\.(ru|co|cu|com|info|net|org|gov|edu|int|mil|biz|pp|ne|msk|spb|nnov|od|in|ho|cc|dn|i|tut|v|dp|sl|ddns|dyndns|livejournal|herokuapp|azurewebsites|cloudfront|ucoz|3dn|nov|linode|amazonaws|sl-reverse|kiev)\.[^.]+$', host):
            shost = re.sub(r'(.+)\.([^.]+\.[^.]+\.[^.]+$)', "\2", host)
        else:
            shost = re.sub(r'/(.+)\.([^.]+\.[^.]+$)', "\2", host)

        for k in self.config["dn"]:
            rx = '\.' + k[0] + '$'
            if re.search(rx, shost):
                shost = re.sub(rx, k[1], shost)
                break
        
        oip = dnsResolve(host)
        iphex = "";
        if oip:
            iphex = str(oip).split(".");
            iphex = pphs(int(iphex[3]) + int(iphex[2])*256 + int(iphex[1])*65536 + int(iphex[0])*16777216)
        
        if iphex:
            for i in range(0, len(self.config["ips"]) - 1):
                if iphex == self.config["ips"][i]:
                    h, t = get_server_for_rtype(rtype, self.config["servers_usual"])
                    return urllib2.ProxyHandler.proxy_open(self, req, h, t)

        for i in range (0, len(self.config["domains"]) - 1):
            if shost == self.config["domains"][i]:
                h, t = get_server_for_rtype(rtype, self.config["servers_usual"])
                return urllib2.ProxyHandler.proxy_open(self, req, self.config["servers_usual"]['http'], rtype)

        for i in range (0, len(self.config["specials"]) - 1):
            if isinstance(self.config["specials"][i][1], int):
                self.config["specials"][i][1] = nmfc(self.config["specials"][i][1])
            
            if isInNet(oip, self.config["specials"][i][0], self.config["specials"][i][1]):
                h, t = get_server_for_rtype(rtype, self.config["servers_special"])
                return urllib2.ProxyHandler.proxy_open(self, req, h, t)

        return None

def get_server_for_rtype(rtype, servers):
    if rtype in servers:
        return servers[rtype], rtype
    
    for k, v in servers.items():
        return v, k
    
    return None, None

def int2base(x, base):
    if x < 0:
        sign = -1
    elif x == 0:
        return digs[0]
    else:
        sign = 1

    x *= sign
    digits = []

    while x:
        digits.append(digs[int(x % base)])
        x = int(x / base)

    if sign < 0:
        digits.append('-')

    digits.reverse()

    return ''.join(digits)

def _address_in_network(ip, netaddr, mask):
    """
    Like :func:`requests.utils.address_in_network` but takes a quad-dotted netmask.
    """
    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]
    netmask = struct.unpack('=L', socket.inet_aton(mask))[0]
    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask
    return (ipaddr & netmask) == (network & netmask)

def isInNet(host, pattern, mask):
    """
    Pattern and mask specification is done the same way as for SOCKS configuration.

    :param str|PyJsString host: a DNS hostname, or IP address.
        If a hostname is passed, it will be resolved into an IP address by this function.
    :param str|PyJsString pattern: an IP address pattern in the dot-separated format
    :param str|PyJsString mask: mask for the IP address pattern informing which parts of
        the IP address should be matched against. 0 means ignore, 255 means match.
    :returns: True iff the IP address of the host matches the specified IP address pattern.
    :rtype: bool
    """
    host_ip = host if is_ipv4_address(host) else dnsResolve(host)
    if not host_ip or not is_ipv4_address(pattern) or not is_ipv4_address(mask):
        return False
    return _address_in_network(host_ip, pattern, mask)

def dnsResolve(host):
    try:
        return socket.gethostbyname(host)
    except socket.gaierror:
        return  # Eat DNS resolution failures.

def is_ipv4_address(string_ip):
    """
    :rtype: bool
    """
    try:
        socket.inet_aton(string_ip)
    except socket.error:
        return False
    return True

def url_get(url, params={}, headers={}, post=None):

    if params:
        import urllib
        url = "%s?%s" % (url, urllib.urlencode(params))

    if post:
        import urllib
        post = urllib.urlencode(post)

    req = urllib2.Request(url, post)
    req.add_header("User-Agent", USER_AGENT)

    for k, v in headers.items():
        req.add_header(k, v)

    try:
        with closing(urllib2.urlopen(req)) as response:
            data = response.read()
            if response.headers.get("Content-Encoding", "") == "gzip":
                import zlib
                return zlib.decompressobj(16 + zlib.MAX_WBITS).decompress(data)
            return data
    except urllib2.HTTPError as e:
        xbmc.log("[script.elementum.burst]: HTTP Error(%s): %s" % (e.errno, e.strerror), level=xbmc.LOGERROR)
        return None