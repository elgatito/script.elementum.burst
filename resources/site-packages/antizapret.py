# -*- coding: utf-8 -*-

#
# Module taken from https://github.com/afedchin/antizapret
# Many thanks to @afedchin !
# Modificated by @elgatito .
#

import os
import re
import fnmatch
import math
import threading
import socket
import struct
import string
import urllib2
import xbmc
import xbmcaddon

from elementum.provider import log
from contextlib import contextmanager, closing
from xbmc import translatePath

PAC_URL = "http://antizapret.prostovpn.org/proxy.pac"
USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36"
CACHE = 24 * 3600  # 24 hour caching
LOCKS = {}
_config = {}
_custom_hosts = []
digs = string.digits + string.ascii_letters

try:
    PATH_TEMP = translatePath("special://temp").decode(sys.getfilesystemencoding(), 'ignore')
except:
    PATH_TEMP = translatePath("special://temp").decode('utf-8')

CACHE_DIR = os.path.join(PATH_TEMP, 'burst')
if not os.path.exists(CACHE_DIR):
    try:
        os.makedirs(CACHE_DIR)
    except Exception as e:
        log.debug("Error creating cache directory: %s" % repr(e))
if not os.access(CACHE_DIR, os.W_OK):
    log.error("Directory '%s' is not writable, antizapret will not work" % CACHE_DIR)
    CACHE_DIR = ""

# Use these values for debugging
# CACHE_DIR="/var/tmp/pac/"
# CACHE = 1


@contextmanager
def shelf(filename, ttl=0):
    import shelve
    filename = os.path.join(CACHE_DIR, filename)
    with LOCKS.get(filename, threading.RLock()):
        with closing(shelve.open(filename, writeback=True)) as d:
            import time
            if not d:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            elif ttl > 0 and (time.time() - d["created_at"]) > ttl:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            yield d["data"]

def config():
    global _config
    if not _config and CACHE_DIR:
        with shelf("antizapret.pac_config", ttl=CACHE) as pac:
            if not pac.get("value"):
                data = None
                log.info("Fetching Antizapret PAC file")
                try:
                    req = urllib2.Request(PAC_URL, headers={ 
                        'User-Agent': USER_AGENT,         
                        'Accept-Encoding': 'gzip',
                        'Origin': PAC_URL,
                        'Referer': PAC_URL
                    })
                    response = urllib2.urlopen(req)
                    if response.headers.get("Content-Encoding", "") == "gzip":
                        import zlib
                        data = zlib.decompressobj(16 + zlib.MAX_WBITS).decompress(response.read())
                    else:
                        data = response.read()

                except Exception as e:
                    log.error("Fetching Antizapret PAC failed with code: %s" % (repr(e)))
                    data = ""

                pac["value"] = {
                    "servers_usual": [],
                    "servers_special": [],
                    "domains": [],
                    "specials": [],
                    "ips": [],
                    "dn": [],
                }

                # Find servers for specific cases
                r_usual = re.search(r'if \(yip === 1 \|\| shost === curarr\[i\]\) \{.*?return "(.*?)".*?\}', data, flags=re.DOTALL)
                r_special = re.search(r'if \(isInNet\(oip, special\[i\]\[0\], special\[i\]\[1\]\)\) \{return "(.*?)";\}', data, flags=re.DOTALL)
                
                # Find arrays containing domains
                res = re.findall(r'(d_\w+) = "(.*?)"', data, flags=re.DOTALL)

                r_list_special = re.search(r'special = \[(.*?)\];', data, flags=re.DOTALL)
                r_dn = re.search(r'dn = \{(.*?)\};', data, flags=re.DOTALL)

                if r_usual:
                    pac["value"]["servers_usual"] = get_servers(r_usual.group(1))
                if r_special:
                    pac["value"]["servers_special"] = get_servers(r_special.group(1))

                if r_dn:
                    ary = r_dn.group(1).replace("'", "").split(", ")
                    for i in ary:
                        # ary2 = i.split(":")
                        # pac["value"]["dn"].append([i[1], i[0]])
                        pac["value"]["dn"].append(i.split(":"))

                if r_list_special:
                    for i in r_list_special.group(1).replace('],[', ']  ,  [').replace('"', '').split("  ,  "):
                        s = i.replace('[', '').replace(']', '').rstrip(',')
                        ary = s.strip().rstrip(',').split(', ')
                        pac["value"]["specials"].append([ary[0], int(ary[1])])

                if res:
                    domains = ""
                    ips = ""

                    for r in res:
                        l = r[1].replace('\\', '')

                        if r[0] == 'd_ipaddr':
                            ips += l
                        else:
                            domains += l

                    pac["value"]["domains"] = domains.split(" ")
                    pac["value"]["ips"] = re.findall(r'.{8}', ips, flags=re.DOTALL)

            _config = pac["value"]
    return _config

def nmfc(b):
    return socket.inet_ntoa(struct.pack("<L", b))

def pphs(n):
    r = int2base(n, 16)
    if len(r) % 2:
        return "0" + r 
    return r

def get_servers(inp):
    ary = {}
    for e in inp.split("; "):
        r = e.replace(";", "").split(" ")
        r[0] = r[0].lower()
        if r[0] == 'proxy':
            r[0] = 'http'
        elif r[0] == 'direct':
            continue
        
        # ary[r[0]] = r[0] + "://" + r[1]
        ary[r[0]] = r[1]
    return ary


def config_add(host):
    host = host.split(':')[0]
    if host not in _custom_hosts:
        _custom_hosts.append(host)


class AntizapretDetector:
    def __init__(self):
        try:
            self.config = config()
        except Exception as e:
            log.error("Got an exception from config composer: %s" % (repr(e)))
            self.config = None
            pass

    def detect(self, host="", scheme=""):
        if not self.config:
            return None

        if re.search(r'\.(ru|co|cu|com|info|net|org|gov|edu|int|mil|biz|pp|ne|msk|spb|nnov|od|in|ho|cc|dn|i|tut|v|dp|sl|ddns|dyndns|livejournal|herokuapp|azurewebsites|cloudfront|ucoz|3dn|nov|linode|amazonaws|sl-reverse|kiev)\.[^.]+$', host):
            shost = re.sub(r'(.+)\.([^.]+\.[^.]+\.[^.]+$)', "\2", host)
        else:
            shost = re.sub(r'/(.+)\.([^.]+\.[^.]+$)', "\2", host)

        for k in self.config["dn"]:
            rx = '\.' + k[0] + '$'
            if re.search(rx, shost):
                shost = re.sub(rx, k[1], shost)
                break
        
        oip = dnsResolve(host)
        iphex = "";
        if oip:
            iphex = str(oip).split(".");
            iphex = pphs(int(iphex[3]) + int(iphex[2])*256 + int(iphex[1])*65536 + int(iphex[0])*16777216)
        
        if iphex:
            for i in range(0, len(self.config["ips"]) - 1):
                if iphex == self.config["ips"][i]:
                    h, t = get_server_for_rtype(rtype, self.config["servers_usual"])
                    return "{}://{}".format(t, h)

        for i in range (0, len(self.config["domains"]) - 1):
            if shost == self.config["domains"][i]:
                h, t = get_server_for_rtype(scheme, self.config["servers_usual"])
                return "{}://{}".format(scheme, self.config["servers_usual"]['http'])

        for i in range (0, len(self.config["specials"]) - 1):
            if isinstance(self.config["specials"][i][1], int):
                self.config["specials"][i][1] = nmfc(self.config["specials"][i][1])
            
            if oip and isInNet(oip, self.config["specials"][i][0], self.config["specials"][i][1]):
                h, t = get_server_for_rtype(scheme, self.config["servers_special"])
                return "{}://{}".format(t, h)

        return None


class AntizapretProxyHandler(urllib2.ProxyHandler, object):

    def __init__(self):
        self.config = config()
        urllib2.ProxyHandler.__init__(self, {
            "http": "<empty>",
            "https": "<empty>",
            "ftp": "<empty>",
        })

    def proxy_open(self, req, proxy, rtype):
        import socket
        global _custom_hosts

        host = req.get_host().split(":")[0]

        if re.search(r'\.(ru|co|cu|com|info|net|org|gov|edu|int|mil|biz|pp|ne|msk|spb|nnov|od|in|ho|cc|dn|i|tut|v|dp|sl|ddns|dyndns|livejournal|herokuapp|azurewebsites|cloudfront|ucoz|3dn|nov|linode|amazonaws|sl-reverse|kiev)\.[^.]+$', host):
            shost = re.sub(r'(.+)\.([^.]+\.[^.]+\.[^.]+$)', "\2", host)
        else:
            shost = re.sub(r'/(.+)\.([^.]+\.[^.]+$)', "\2", host)

        for k in self.config["dn"]:
            rx = '\.' + k[0] + '$'
            if re.search(rx, shost):
                shost = re.sub(rx, k[1], shost)
                break
        
        oip = dnsResolve(host)
        iphex = "";
        if oip:
            iphex = str(oip).split(".");
            iphex = pphs(int(iphex[3]) + int(iphex[2])*256 + int(iphex[1])*65536 + int(iphex[0])*16777216)
        
        if iphex:
            for i in range(0, len(self.config["ips"]) - 1):
                if iphex == self.config["ips"][i]:
                    h, t = get_server_for_rtype(rtype, self.config["servers_usual"])
                    return urllib2.ProxyHandler.proxy_open(self, req, h, t)

        for i in range (0, len(self.config["domains"]) - 1):
            if shost == self.config["domains"][i]:
                h, t = get_server_for_rtype(rtype, self.config["servers_usual"])
                return urllib2.ProxyHandler.proxy_open(self, req, self.config["servers_usual"]['http'], rtype)

        for i in range (0, len(self.config["specials"]) - 1):
            if isinstance(self.config["specials"][i][1], int):
                self.config["specials"][i][1] = nmfc(self.config["specials"][i][1])
            
            if isInNet(oip, self.config["specials"][i][0], self.config["specials"][i][1]):
                h, t = get_server_for_rtype(rtype, self.config["servers_special"])
                return urllib2.ProxyHandler.proxy_open(self, req, h, t)

        return None

def get_server_for_rtype(rtype, servers):
    if rtype in servers:
        return servers[rtype], rtype
    
    for k, v in servers.items():
        return v, k
    
    return None, None

def int2base(x, base):
    if x < 0:
        sign = -1
    elif x == 0:
        return digs[0]
    else:
        sign = 1

    x *= sign
    digits = []

    while x:
        digits.append(digs[int(x % base)])
        x = int(x / base)

    if sign < 0:
        digits.append('-')

    digits.reverse()

    return ''.join(digits)

def _address_in_network(ip, netaddr, mask):
    """
    Like :func:`requests.utils.address_in_network` but takes a quad-dotted netmask.
    """
    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]
    netmask = struct.unpack('=L', socket.inet_aton(mask))[0]
    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask
    return (ipaddr & netmask) == (network & netmask)

def isInNet(host, pattern, mask):
    """
    Pattern and mask specification is done the same way as for SOCKS configuration.

    :param str|PyJsString host: a DNS hostname, or IP address.
        If a hostname is passed, it will be resolved into an IP address by this function.
    :param str|PyJsString pattern: an IP address pattern in the dot-separated format
    :param str|PyJsString mask: mask for the IP address pattern informing which parts of
        the IP address should be matched against. 0 means ignore, 255 means match.
    :returns: True iff the IP address of the host matches the specified IP address pattern.
    :rtype: bool
    """
    host_ip = host if is_ipv4_address(host) else dnsResolve(host)
    if not host_ip or not is_ipv4_address(pattern) or not is_ipv4_address(mask):
        return False
    return _address_in_network(host_ip, pattern, mask)

def dnsResolve(host):
    try:
        return socket.gethostbyname(host)
    except socket.gaierror:
        return  # Eat DNS resolution failures.

def is_ipv4_address(string_ip):
    """
    :rtype: bool
    """
    try:
        socket.inet_aton(string_ip)
    except socket.error:
        return False
    return True

def url_get(url, params={}, headers={}, post=None):

    if params:
        import urllib
        url = "%s?%s" % (url, urllib.urlencode(params))

    if post:
        import urllib
        post = urllib.urlencode(post)

    req = urllib2.Request(url, post)
    req.add_header("User-Agent", USER_AGENT)

    for k, v in headers.items():
        req.add_header(k, v)

    try:
        with closing(urllib2.urlopen(req)) as response:
            data = response.read()
            if response.headers.get("Content-Encoding", "") == "gzip":
                import zlib
                return zlib.decompressobj(16 + zlib.MAX_WBITS).decompress(data)
            return data
    except urllib2.HTTPError as e:
        log.error("HTTP Error(%s): %s" % (e.errno, e.strerror))
        return None