# -*- coding: utf-8 -*-
# Module parses antizapret Proxy Auto Configuration (PAC) file in order to find if domain/ip is blocked and needs proxy.


import os
import re
import base64
import socket
import struct
import threading
import xbmcaddon
from six import PY2, PY3
from six.moves import urllib_request
from contextlib import contextmanager, closing
from elementum.provider import log
try:
    from xbmcvfs import translatePath
except ImportError:
    from xbmc import translatePath

ADDON = xbmcaddon.Addon()
PAC_URL = ADDON.getSetting('antizapret_pac_url')
USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
CACHE = 24 * 3600  # 24 hour caching
LOCKS = {}
_config = {}

if PY3:
    CONFIG_FILE_NAME = "antizapret_config_py3.pickle"
if PY2:
    CONFIG_FILE_NAME = "antizapret_config_py2.pickle"
PATH_TEMP = translatePath("special://temp")
CACHE_DIR = os.path.join(PATH_TEMP, 'burst')
# Use these values for debugging
# CACHE_DIR = "/tmp/antizapret/"
# CACHE = 1
if not os.path.exists(CACHE_DIR):
    try:
        os.makedirs(CACHE_DIR)
    except Exception as e:
        error_message = "Error creating cache directory: %s" % repr(e)
        log.error(error_message)
if not os.access(CACHE_DIR, os.W_OK):
    error_message = "Directory '%s' is not writable, antizapret will not work" % CACHE_DIR
    log.error(error_message)
    CACHE_DIR = ""  # for if in config()


# CIDR to netmask, for "special" variable
def cidr_to_netmask(cidr):
    host_bits = 32 - int(cidr)
    netmask = socket.inet_ntoa(struct.pack('!I', (1 << 32) - (1 << host_bits)))
    return netmask


# replace repeating sequences in domain to make it shorter
def patternreplace(s, patterns):
    for pattern in patterns:
        s = s.replace(patterns[pattern], pattern)
    return s


# restore repeating sequences in domain to get initial name
def patternrestore(s, patterns):
    for pattern in patterns:
        s = s.replace(pattern, patterns[pattern])
    return s


# variables for unlzp function
TABLE_LEN_BITS = 18
HASH_MASK = (1 << TABLE_LEN_BITS) - 1
table = [0] * (1 << TABLE_LEN_BITS)
hash_value = 0


# Point-to-Point Protocol (PPP) compression algorithm or LZP (LZ Prediction) by Charles Bloom.
# https://bitbucket.org/anticensority/antizapret-pac-generator-light/src/master/scripts/lzp.py
def unlzp(d, m, lim):
    global table, hash_value  # Need to modify global state
    mask = 0
    maskpos = 0
    dpos = 0
    out = [""] * 8
    outpos = 0
    outfinal = ""

    m_len = len(m)
    d_len = len(d)

    while True:
        if maskpos >= m_len:
            break
        mask = m[maskpos]
        maskpos += 1
        outpos = 0
        for i in range(8):
            if mask & (1 << i):
                c = table[hash_value]
            else:
                if dpos >= d_len:
                    break
                c = d[dpos]
                c = ord(c)
                table[hash_value] = c
                dpos += 1
            out[outpos] = chr(c)
            outpos += 1
            hash_value = ((hash_value << 7) ^ c) & HASH_MASK
        if outpos == 8:
            outfinal += "".join(out)
        if len(outfinal) >= lim:
            break
    if outpos < 8:
        outfinal += "".join(out[:outpos])
    return outfinal, dpos, maskpos


# base64 decode
def a2b(a):
    if PY3:
        return base64.b64decode(a)
    if PY2:
        return bytearray(base64.b64decode(a))


if PY3:  # In Python 3 we can simply use standard ipaddress module
    import ipaddress
    # Simulate PAC standard function isInNet
    def isInNet(ipaddr, netaddr, netmask):
        """Checks if IP address is in network specified by netaddr/netmask.

        :param host: IP address.
        :type host: str
        :param netaddr: IP address pattern.
        :type netaddr: str
        :param netmask: network mask (not CIDR).
        :type netmask: str
        :returns: True if the IP address is in network, otherwise False.
        :rtype: bool
        """
        if not ipaddr:  # Handle None from dnsResolve
            return False
        try:
            ip_addr_obj = ipaddress.ip_address(ipaddr)
            net_obj = ipaddress.ip_network("{}/{}".format(netaddr, netmask), strict=False)
            # Check if the resolved IP address is within the network defined by netaddr/netmask
            return ip_addr_obj in net_obj
        except ValueError:
            # Invalid IP address, prefix, or netmask format
            return False
        except Exception:
            # Catch other potential errors
            return False
if PY2:  # Python 2 does not have embedded ipaddress module
    def isInNet(ipaddr, netaddr, netmask):
        """Checks if IP address is in network specified by netaddr/netmask.

        :param host: IP address.
        :type host: str
        :param netaddr: IP address pattern.
        :type netaddr: str
        :param netmask: network mask (not CIDR).
        :type netmask: str
        :returns: True if the IP address is in network, otherwise False.
        :rtype: bool
        """
        if not ipaddr:  # Handle None from dnsResolve
            return False
        if not _is_ipv4_address(ipaddr) or not _is_ipv4_address(netaddr) or not _is_ipv4_address(netmask):
            return False
        return _ipaddress_in_network(ipaddr, netaddr, netmask)

    def _ipaddress_in_network(ip, netaddr, mask):
        """
        Like `requests.utils.address_in_network` but takes a quad-dotted netmask.
        """
        ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]
        netmask = struct.unpack('=L', socket.inet_aton(mask))[0]
        network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask
        return (ipaddr & netmask) == (network & netmask)

    def _is_ipv4_address(string_ip):
        """
        :rtype: bool
        """
        try:
            socket.inet_aton(string_ip)
        except socket.error:
            return False
        return True


# Simulate PAC standard function dnsResolve
def dnsResolve(host):
    try:
        # Standard PAC dnsResolve returns only the first A record, so does gethostbyname.
        # For IPv6 getaddrinfo could be used but our PAC file has only IPv4 networks.
        return socket.gethostbyname(host)
    except socket.gaierror:
        # Ignore errors.
        return None
    except Exception:
        return None


# function to store cache
@contextmanager
def shelf(filename, ttl=0):
    import shelve
    filename = os.path.join(CACHE_DIR, filename)
    with LOCKS.get(filename, threading.RLock()):
        with closing(shelve.open(filename, writeback=True)) as d:
            import time
            if not d:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            elif ttl > 0 and (time.time() - d["created_at"]) > ttl:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            yield d["data"]


# Build Antizapret config and store it in cache
def config():
    global _config
    if not _config and CACHE_DIR:
        with shelf(CONFIG_FILE_NAME, ttl=CACHE) as pac:
            if not pac.get("value"):
                data = None
                message = "Fetching Antizapret PAC file"
                log.info(message)
                try:
                    req = urllib_request.Request(PAC_URL, headers={
                        'User-Agent': USER_AGENT,
                        'Accept-Encoding': 'gzip',
                        'Origin': PAC_URL,
                        'Referer': PAC_URL
                    })
                    response = urllib_request.urlopen(req)
                    if response.headers.get("Content-Encoding", "") == "gzip":
                        import zlib
                        data = zlib.decompressobj(31).decompress(response.read())
                    else:
                        data = response.read()
                    if PY3:
                        data = data.decode("utf-8")
                except Exception as e:  # TODO: probably we can re-use stale cache if antizapret pac file is unavailable or blocked.
                    error_message = "Fetching Antizapret PAC file failed: %s" % (repr(e))
                    log.error(error_message)
                    raise Exception(error_message)

                message = "Parsing Antizapret PAC file"
                log.info(message)
                try:
                    # domains is a dictionary, key is domain name, value is the dictionary where key is length and value is length of the string that contains those domain names and each domain name has length specified in key.
                    domains_groups = re.search(r'domains = \{(.*?)\};', data, flags=re.DOTALL)
                    # dictionary "domains" must have keys in defined order, otherwise unzlp will not work. JavaScript preserves keys order.
                    if PY3:  # Python 3 also preserve keys order in dict, so we can simply use eval.
                        domains = eval('{' + domains_groups.group(1) + '}')
                    if PY2:  # Python 2 does NOT preserve keys order in dict, so we have to use OrderedDict and parse strings.
                        from collections import OrderedDict
                        domains = OrderedDict()
                        try:
                            for line in domains_groups.group(1).split():
                                key, val = line.split(':', 1)
                                domain = key.strip('"')
                                values = val.rstrip(',').strip('{}').split(',')
                                values_as_ordered_dict = OrderedDict()
                                for value in values:
                                    dcnt_str, dmnl_str = value.split(':', 1)
                                    dcnt = int(dcnt_str)
                                    dmnl = int(dmnl_str)
                                    values_as_ordered_dict[dcnt] = dmnl
                                domains[domain] = values_as_ordered_dict
                        except Exception as e:
                            error_message = "Failed to parse line {}: {}".format(line, e)
                            log.warning(error_message)

                    # Initially d_ipaddr stores differences as numbers with base=36,
                    # then during initialization we convert them to IP as big-endian integer.
                    d_ipaddr_groups = re.search(r'var d_ipaddr = "(.*?)"', data, flags=re.DOTALL)
                    d_ipaddr = d_ipaddr_groups.group(1).replace('\\', '').replace('\n', '').split()

                    # list of subnets with CIDR
                    special_groups = re.search(r'var special = (\[.*?\]);', data, flags=re.DOTALL)
                    special = eval(special_groups.group(1))

                    # domain name data encoded with LZP, without mask data
                    domains_lzp_groups = re.search(r'var domains_lzp = "(.*?)";', data, flags=re.DOTALL)
                    domains_lzp = domains_lzp_groups.group(1).replace('\\', '').replace('\n', '')

                    # LZP mask data, base64+patternreplace
                    mask_lzp_groups = re.search(r'var mask_lzp = "(.*?)";', data, flags=re.DOTALL)
                    mask_lzp = mask_lzp_groups.group(1).replace('\\', '').replace('\n', '')

                    # patterns for patternreplace/patternrestore
                    patterns_groups = re.findall(r'var patterns = (\{.*?\});', data, flags=re.DOTALL)
                    # dictionaries patterns_domains_lzp and patterns_mask_lzp must have keys in defined order, otherwise patternreplace/patternrestore will not work correctly.
                    if PY3:  # Python 3 also preserve keys order in dict, so we can simply use eval.
                        patterns_domains_lzp = eval(patterns_groups[0])
                        patterns_mask_lzp = eval(patterns_groups[1])
                    if PY2:  # Python 2 does NOT preserve keys order in dict, so we have to make replacements in string and use OrderedDict.
                        from collections import OrderedDict
                        patterns_domains_lzp = OrderedDict()
                        try:
                            for kv in patterns_groups[0].strip('{}').split(', '):
                                k, v = kv.split(': ', 1)
                                key = eval(k)
                                value = eval(v)
                                patterns_domains_lzp[key] = value
                        except Exception as e:
                            error_message = "Failed to parse kv {} in patterns_domains_lzp: {}".format(kv, e)
                            log.warning(error_message)
                        patterns_mask_lzp = OrderedDict()
                        try:
                            for kv in patterns_groups[1].strip('{}').split(', '):
                                k, v = kv.split(': ', 1)
                                key = eval(k)
                                value = eval(v)
                                patterns_mask_lzp[key] = value
                        except Exception as e:
                            error_message = "Failed to parse kv {} in patterns_mask_lzp: {}".format(kv, e)
                            log.warning(error_message)

                    three_part_suffixes_pattern_groups = re.search(r'if \(/(.*?)/.test\(host\)\)', data)
                    three_part_suffixes_pattern = three_part_suffixes_pattern_groups.group(1)

                    proxy_groups = re.search(r'return "HTTPS ([^;]*?); PROXY ([^;]*?);', data)  # if we got "proxy-ssl.js" file
                    if proxy_groups:
                        if PY3:
                            proxy_server = proxy_groups.group(1)
                            proxy_scheme = 'https://'
                        if PY2:  # otherwise Exception: TLS in TLS requires SSLContext.wrap_bio() which isn't supported on Python 2
                            proxy_server = proxy_groups.group(2)
                            proxy_scheme = 'http://'
                    else:
                        proxy_groups = re.search(r'return "PROXY ([^;]*?);', data)  # if we got "proxy-nossl.js" file
                        if proxy_groups:
                            proxy_server = proxy_groups.group(1)
                            proxy_scheme = 'http://'
                    if not proxy_groups:
                        error_message = "Can't find proxy URL"
                        log.error(error_message)
                        raise Exception(error_message)
                    proxy_url = proxy_scheme + proxy_server
                except Exception as e:
                    error_message = "Parsing Antizapret PAC file failed: %s" % (repr(e))
                    log.error(error_message)
                    raise Exception(error_message)

                message = "Initializing Antizapret config"
                log.info(message)
                try:
                    prev_ipval = 0
                    for i in range(len(d_ipaddr)):
                        cur_ipval = int(d_ipaddr[i], 36) + prev_ipval
                        d_ipaddr[i] = cur_ipval
                        prev_ipval = cur_ipval

                    for i in range(len(special)):
                        special[i][1] = cidr_to_netmask(special[i][1])

                    mask_lzp = a2b(patternreplace(mask_lzp, patterns_mask_lzp))
                    leftover = ""
                    for dmn in domains:
                        for dcnt in domains[dmn]:
                            dmnl = domains[dmn][dcnt]
                            if len(leftover) < dmnl:  # need to unpack string
                                reqd = max(8192, dmnl)
                                if not domains_lzp or not mask_lzp:
                                    error_message = "Warning: Ran out of LZP data during initialization."
                                    log.warning(error_message)
                                    break
                                u = unlzp(domains_lzp, mask_lzp, reqd)
                                domains_lzp = domains_lzp[u[1]:]
                                mask_lzp = mask_lzp[u[2]:]
                                leftover += u[0]
                                u = None
                            if len(leftover) < dmnl:
                                error_message = "Warning: Decompression did not yield enough data for domains['{}']['{}'] (needed {}, got {}). Storing partial data.".format(dmn, dcnt, dmnl, len(leftover))
                                log.warning(error_message)
                            domains[dmn][dcnt] = leftover[:dmnl]
                            leftover = leftover[dmnl:]
                            # split domains line by dcnt length
                            regex = re.compile(".{" + str(dcnt) + "}", re.DOTALL)
                            domains[dmn][dcnt] = regex.findall(domains[dmn][dcnt])
                        else:
                            continue  # Continue if the inner loop wasn't broken.
                        break  # Inner loop was broken, break the outer.
                    global table
                    table = None

                    pac["value"] = {
                        "domains": domains,
                        "special": special,
                        "d_ipaddr": d_ipaddr,
                        "proxy_url": proxy_url,
                        "patterns_domains_lzp": patterns_domains_lzp,
                        "patterns_mask_lzp": patterns_mask_lzp,
                        "three_part_suffixes_pattern": three_part_suffixes_pattern,
                    }

                    # Debug info
                    # print("Number of blocked IP addresses = {}".format(len(d_ipaddr)))
                    # # for iphex in d_ipaddr:
                    # #     print(socket.inet_ntoa(struct.pack(">L", iphex)))
                    # len_domains = 0
                    # for dmn in domains.keys():
                    #     # print("domain=%s" % dmn)
                    #     for dcnt in domains[dmn]:
                    #         # print("dcnt=%s" % dcnt)
                    #         for domain in domains[dmn][dcnt]:
                    #             # print(patternrestore(domain, patterns_domains_lzp) + "." + dmn)
                    #             len_domains += 1
                    # print("Number of blocked domains = {}".format(len_domains))
                except Exception as e:
                    error_message = "Initializing Antizapret config failed: %s" % (repr(e))
                    log.error(error_message)
                    raise Exception(error_message)
            else:
                message = "Using cached Antizapret config"
                log.info(message)
            _config = pac["value"]
    return _config


class AntizapretProxy(object):

    def __init__(self):
        try:
            self.config = config()
        except Exception as e:
            error_message = "Got an exception during config generation: %s" % (repr(e))
            log.error(error_message)
            self.config = None

    def detect(self, host=""):
        if not self.config:
            return None

        # remove port
        host = host.split(":")[0]

        shost = host
        if re.search(self.config["three_part_suffixes_pattern"], host):
            shost = re.sub(r"(.+)\.([^.]+\.[^.]+\.[^.]+$)", r"\2", host)
        else:
            shost = re.sub(r"(.+)\.([^.]+\.[^.]+$)", r"\2", host)

        shost = shost.removeprefix("www.")  # remove leading www

        curdomain = re.match(r"(.*)\.([^.]+$)", shost)
        if not curdomain or not curdomain.group(1):
            return None
        curhost = curdomain.group(1)
        curzone = curdomain.group(2)
        curhost = patternreplace(curhost, self.config["patterns_domains_lzp"])
        curarr = []
        if curzone in self.config["domains"] and len(curhost) in self.config["domains"][curzone]:
            curarr = self.config["domains"][curzone][len(curhost)]

        oip = False
        # Do not resolve IPv4/v6 addresses to prevent slowdown
        if not re.match(r"^[0-9a-fA-F:.]*$", host):
            oip = dnsResolve(host)
        iphex = ""
        if oip:
            iphex = struct.unpack('>L', socket.inet_aton(oip))[0]
        yip = 0
        rip = 0
        if iphex and iphex in self.config["d_ipaddr"]:
            yip = 1
        for i in range(len(self.config["special"])):
            if isInNet(oip, self.config["special"][i][0], self.config["special"][i][1]):
                rip = 1
                break
        if yip == 1 or rip == 1 or curhost in curarr:
            return self.config["proxy_url"]

        return None
